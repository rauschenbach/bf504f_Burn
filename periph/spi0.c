/****************************************************************************** 
 * SPI0 - работа по SPI0 с подключенными АЦП, ранее АЦП работали по 
 * неправило-разведенному SPORT, SPI дергался руками/
 * По DMA не работает - напарывается на anomaly 
****************************************************************************************/
#include "utils.h"
#include "spi0.h"
#include "pll.h"
#include "irq.h"


/* Выводы переделали вот так:  */
#define  	_1282_SCLK			PF10
#define  	_1282_DOUT			PF11	/* Выход из АЦП в DSP  */
#define  	_1282_DIN			PF12	/* Вход в АЦП из DSP */

#define  	SPI_SCK				_1282_SCLK
#define  	SPI_MISO			_1282_DOUT
#define		SPI_MOSI			_1282_DIN

#define		SPI0_SCLK			 ADS1282_SPI_SPEED

/******************************************************************************************* 
 * Запрограммировать SPI0 для обмена с АЦП ADS1282 проверить при Fsclk АЦП до 2 МГц 
 * между байтами д.б. как минимум 24 периода SCLK при передаче и приеме из регистров.
 * Порты: PF8, PF9, PF10, PF11, PF12, PF14, PF15 
 * Сделать чтение по DMA! (ANOMALY!!!)
 ******************************************************************************************/
#pragma section("FLASH_code")
void SPI0_init(void)
{
	/* SPI0 на портах PF10..PF12, 1-я функция, MUX = 00 */
	*pPORTF_FER |= (SPI_SCK | SPI_MISO | SPI_MOSI);
	*pPORTFIO_DIR |= (SPI_SCK | SPI_MOSI);	/* Выходы */
	*pPORTFIO_INEN |= SPI_MISO;	/* Вход */
	*pPORTF_MUX &= ~((1 << 10) | (1 << 11));	/* 1-я функция, биты 10 и 11 в нуле */

	/* Настраиваем SPI0 для работы с АЦПи  ADS1282 
	 * расчитаем делитель для
	 * SPI_BAUD  = SCLK_VALUE / (2 * 1 000 000) 
	 * Делитель ~ 24 при работе на на 1 мегагерце
	 */

	/* SPI_CTL настройка SPI:
	 * CPOL=0, CHPA=0 (MODE 0), полярность0 + фаза0 + MSB + 8 бит 
	 * Разрешими MISO + overwrite previous data, 
	 * SPI запускается записью в рег. передачи
	 * разрешить SPI0,
	 */
	*pSPI0_CTL = SPE | MSTR | EMISO | CPHA | 0x0001;
	*pSPI0_BAUD = SCLK_VALUE / (2 * SPI0_SCLK);	
}


/****************************************************************************************
 * Убрать тактирование с SPI0
 * Выключить SPI0
 *************************************************************************************/
#pragma section("FLASH_code")
void SPI0_stop(void)
{
	*pSPI0_CTL = 0;

	/* На вход выводы */
	*pPORTF_FER |= (SPI_SCK | SPI_MISO | SPI_MOSI);
	*pPORTFIO_INEN |= (SPI_MISO | SPI_SCK | SPI_MOSI);	/* Вход */
	*pPORTF_MUX &= ~((1 << 10) | (1 << 11));	/* 1-я функция, биты 10 и 11 в нуле */
	 ssync();
}

/*****************************************************************************************
 * Запись с одновременным чтением: 8 бит в SPI0, адрес выбирается PF14 и PF15
 * параметр: байт на передачу
 * возврат:  принятый байт
 *****************************************************************************************/
section("L1_code")
u8 SPI0_write_read(u8 data)
{
	u8 byte;

	/*ждём пока не освободится буфер передачи */
	while (*pSPI0_STAT & TXS);
	*pSPI0_TDBR = data;	/* Послали байт или dummy */

	/*ждём окончания отправки пред. пакета */
	while (!(*pSPI0_STAT & RXS));
	 byte = *pSPI0_RDBR;	/* Примем dummy или байт */

	return byte;
}
